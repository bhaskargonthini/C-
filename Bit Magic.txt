BIT MAGIC|:
=========================================
Bitwise AND: eg: 0 0 = 0              Bitwise Left Shift: 3<<1 = 011 -> 110
				 1 0 = 0   								  3<<2 = 011 -> 1100
				 0 1 = 0								  3<<3 = 011 -> 11000
				 1 1 = 1			   --If we assume that the leading y bits are 0, then result of (x>>y) is
										equivalent to x*2^y.
Bitwise OR: eg:  0 0 = 0				eg: 3<<1 = 6 = 3*2^1
				 1 0 = 1					3<<2 = 12 = 3*2^2
				 0 1 = 1
				 1 1 = 1
				 
Bitwise XOR: eg: 0 0 = 0			Bitwise right Shift: 33>>1 = 100001 -> 0010000
				 1 0 = 1								 33>>2 = 100001 -> 0001000
				 0 0 = 1		       --x>>y is equivalent to |x/2^y|
				 1 1 = 0  									 eg: 33>>1 = 33/2^1 = 16
																 33>>2 = 33/2^2 = 8
Bitwise NOT: all the bits are inverted
		x = 1: x: 0000001  
		~x =   x: 1111110
		if all the bit values of a number are 1's
		then the value can be calculated as (2^n)-1
		where n is number of 1's.
		eg: 111 = (2^3)-1 = 7

Signed Input:
			signed numbers when they are negative will be stored using 
			2's compliment.
				2's compliment: 2^n-x
----------------------------------------------
problems:

Check Kth bit is set or not:
	Using left shift operator:
					void isKthBitSet(int n, int k) 
					{ 
						if (n & (1 << (k - 1))) 
							cout << "SET"; 
						else
							cout << "NOT SET"; 
					} 
	Using right shift operator:
					void isKthBitSet(int n, int k) 
					{ 
						if ((n >> (k - 1)) & 1) 
							cout << "SET"; 
						else
							cout << "NOT SET"; 
					} 
-----------------------------------------------------

Count set bits: 
	Naive solution:
			unsigned int countSetBits(unsigned int n) 
			{ 
				unsigned int count = 0; 
				while (n != 0) {        
					if (n % 2 != 0)      or if((n&1) == 1)
					   count++;				 count++;
					n = n/2;      			n = n>>1;
				} 
				return count; 
			} 
	Method 2 (BRIAN AND KERNINGHAM ALGORITHM):
	we can always unset the rightmost set bit in a number by doing 
			AND operation with (n-1).
			
			unsigned int countSetBits(int n)             101000       n = 40
			{                                            100111       n-1 = 39
				   unsigned int count = 0;               	40 & 39 = 100000 = 32 
				   while (n) {                              
					  n &= (n - 1);                       100000      n = 32 now       
					  count++;                            011111      n-1 = 31     
				   } 									  	32 & 31 = 0000000 = 0	
				  return count; 
			}
-----------------------------------------------------------
Bit Difference: 

			int countBitsFlip(int a, int b){
					
					// Your logic here
					a^= b;
					int count = 0;
					while(a>0){
						if(a & 1 == 1){               IMPORTANT LOGIC.
							count++;
						}
						a = a>>1;
					}
					return count;
				}		
-------------------------------------------------------------------
POWER OF 2:
				Given  a number, we need to find whether the given number is power of 2 or not.
					
				bool isPow2(int n)
				{
					if(n == 0)
						return false;
					
					return ((n & (n - 1)) == 0);
				}			
		what we doing here is, we unset the only set bit in the number,
		if the resultant number is 0 then it is power of 2.
			
----------------------------------------------------------------------
FIND THE ODD TIME OCCURING NUMBER IN AN ARRAY:
	XOR Operator properties:
		X^0 = X
		X^Y = Y^X
		X^(Y^Z) = (x^Y)^Z
		X^X = 0
		The logic is to do XOR operation on all numbers in an array.
			since X^X = 0, the even occuring numbers will cancel out 
			and only the odd occuring numbers will remain.
			eg: arr[] = {4,3,4,4,4,5,5} no(4) = 4, no(3) = 1, no(5)=2
			 so 3 will be the answer. 
	
	Another variation is to find the missing number in an array of n+1 numbers.
		sol: do xor of all the number in that array and take the resultant array
			and do xor with all the number from 1 to n.
---------------------------------------------------------------------------

SWAP ALL EVEN BITS AND ODD BITS:	
	eg: The task is to swap all odd bits with even bits. For example, if the given number is 23 (00010111), 
	it should be converted to 43(00101011). Here, every even position bit is swapped with adjacent bit on the 
	right side(even position bits are highlighted in the binary representation of 23),
	and every odd position bit is swapped with an adjacent on the left side.
		 unsigned int swapBits(unsigned int n)
   {
    // Your code here
       return (((n & 0xAAAAAAAA) >> 1) | ((n & 0x55555555) << 1));

   }
   
