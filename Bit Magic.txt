BIT MAGIC|:
=========================================
Bitwise AND: eg: 0 0 = 0              Bitwise Left Shift: 3<<1 = 011 -> 110
				 1 0 = 0   								  3<<2 = 011 -> 1100
				 0 1 = 0								  3<<3 = 011 -> 11000
				 1 1 = 1			   --If we assume that the leading y bits are 0, then result of (x>>y) is
										equivalent to x*2^y.
Bitwise OR: eg:  0 0 = 0				eg: 3<<1 = 6 = 3*2^1
				 1 0 = 1					3<<2 = 12 = 3*2^2
				 0 1 = 1
				 1 1 = 1
				 
Bitwise XOR: eg: 0 0 = 0			Bitwise right Shift: 33>>1 = 100001 -> 0010000
				 1 0 = 1								 33>>2 = 100001 -> 0001000
				 0 0 = 1		       --x>>y is equivalent to |x/2^y|
				 1 1 = 0  									 eg: 33>>1 = 33/2^1 = 16
																 33>>2 = 33/2^2 = 8
Bitwise NOT: all the bits are inverted
		x = 1: x: 0000001  
		~x =   x: 1111110
		if all the bit values of a number are 1's
		then the value can be calculated as (2^n)-1
		where n is number of 1's.
		eg: 111 = (2^3)-1 = 7

Signed Input:
			signed numbers when they are negative will be stored using 
			2's compliment.
				2's compliment: 2^n-x
----------------------------------------------
problems:

Check Kth bit is set or not:
	Using left shift operator:
					void isKthBitSet(int n, int k) 
					{ 
						if (n & (1 << (k - 1))) 
							cout << "SET"; 
						else
							cout << "NOT SET"; 
					} 
	Using right shift operator:
					void isKthBitSet(int n, int k) 
					{ 
						if ((n >> (k - 1)) & 1) 
							cout << "SET"; 
						else
							cout << "NOT SET"; 
					} 
-----------------------------------------------------

Count set bits:
	Naive solution:
			unsigned int countSetBits(unsigned int n) 
			{ 
				unsigned int count = 0; 
				while (n != 0) {        
					if (n % 2 != 0)      or if((n&1) == 1)
					   count++;				 count++;
					n = n/2;      			n = n>>1;
				} 
				return count; 
			} 
	Method 2 (BRIAN AND KERNINGHAM ALGORITHM):
			unsigned int countSetBits(int n)             101000       n = 40
			{                                            100111       n-1 = 39
				   unsigned int count = 0;               	40 & 39 = 100000 = 32 
				   while (n) {                              
					  n &= (n - 1);                       100000      n = 32 now       
					  count++;                            011111      n-1 = 31     
				   } 									  	32 & 31 = 0000000 = 0	
				  return count; 
			} 
